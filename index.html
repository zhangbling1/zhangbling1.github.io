<script>
    // =================================================================
    // ğŸ‘‡ğŸ‘‡ğŸ‘‡ âœ¨ çœŸÂ·æ°´æ¯ (Jellyfish) æ ¸å¿ƒç®—æ³• (é‡å†™ç‰ˆ) âœ¨ ğŸ‘‡ğŸ‘‡ğŸ‘‡
    // =================================================================
    const canvas = document.getElementById('particle-canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // é¼ æ ‡ä½ç½® (å¸¦å¹³æ»‘å»¶è¿Ÿ)
    const mouse = { x: width / 2, y: height / 2 };
    const target = { x: width / 2, y: height / 2 };

    window.addEventListener('mousemove', e => {
        target.x = e.clientX;
        target.y = e.clientY;
    });

    // ==================== è§¦é¡»ç±» (Tentacle) ====================
    class Tentacle {
        constructor(length, n, friction, offsetAngle) {
            this.length = length; // è§¦é¡»æ€»é•¿
            this.n = n;           // å…³èŠ‚æ•°é‡
            this.friction = friction; // é˜»åŠ›ï¼ˆè¶Šå°è¶Šç”©ï¼‰
            this.offsetAngle = offsetAngle; // åœ¨å¤´éƒ¨å‘¨å›´çš„åç§»è§’åº¦
            this.nodes = [];      // è§¦é¡»ä¸Šçš„èŠ‚ç‚¹
            
            // åˆå§‹åŒ–èŠ‚ç‚¹
            for (let i = 0; i < this.n; i++) {
                this.nodes.push({ x: 0, y: 0 });
            }
        }

        update(headX, headY, angleOffset) {
            // 1. ç¬¬ä¸€ä¸ªèŠ‚ç‚¹è·Ÿéšå¤´éƒ¨ï¼ˆå¸¦ä¸€ç‚¹åç§»ï¼Œå½¢æˆåœ†å½¢çš„èº«ä½“ï¼‰
            // è®©æˆ‘ä»¬æŠŠè§¦é¡»æ ¹éƒ¨å›ºå®šåœ¨ä¸€ä¸ªè™šæ‹Ÿçš„åœ†å‘¨ä¸Š
            const headRadius = 20; 
            const rootX = headX + Math.cos(this.offsetAngle + angleOffset) * headRadius;
            const rootY = headY + Math.sin(this.offsetAngle + angleOffset) * headRadius;

            this.nodes[0].x += (rootX - this.nodes[0].x) * this.friction;
            this.nodes[0].y += (rootY - this.nodes[0].y) * this.friction;

            // 2. åç»­èŠ‚ç‚¹è·Ÿéšå‰ä¸€ä¸ªèŠ‚ç‚¹ (IK - Inverse Kinematics ç®€åŒ–ç‰ˆ)
            for (let i = 1; i < this.n; i++) {
                const prev = this.nodes[i - 1];
                const curr = this.nodes[i];
                
                // ç®€å•çš„å¼¹ç°§è·Ÿéš
                curr.x += (prev.x - curr.x) * this.friction;
                curr.y += (prev.y - curr.y) * this.friction;
                
                // åŠ å…¥ä¸€ç‚¹æ­£å¼¦æ³¢åŠ¨çš„â€œæ°´æµæ„Ÿâ€
                curr.x += Math.sin(Date.now() * 0.003 + i * 0.2 + this.offsetAngle) * 0.5;
            }
        }

        draw(ctx) {
            ctx.beginPath();
            ctx.moveTo(this.nodes[0].x, this.nodes[0].y);
            
            // ä½¿ç”¨äºŒæ¬¡è´å¡å°”æ›²çº¿è¿æ¥èŠ‚ç‚¹ï¼Œä½¿è§¦é¡»çœ‹èµ·æ¥ä¸æ»‘
            for (let i = 1; i < this.n - 1; i++) {
                const curr = this.nodes[i];
                const next = this.nodes[i + 1];
                const xc = (curr.x + next.x) / 2;
                const yc = (curr.y + next.y) / 2;
                ctx.quadraticCurveTo(curr.x, curr.y, xc, yc);
            }
            
            // æœ€åä¸€èŠ‚
            const last = this.nodes[this.n - 1];
            ctx.lineTo(last.x, last.y);

            // æ ·å¼è®¾ç½®
            ctx.strokeStyle = 'rgba(66, 133, 244, 0.4)'; // è°·æ­Œè“
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.stroke();
            ctx.closePath();
        }
    }

    // ==================== åˆå§‹åŒ–æ°´æ¯ ====================
    const tentacles = [];
    const NUM_TENTACLES = 12; // è§¦é¡»æ•°é‡
    
    for (let i = 0; i < NUM_TENTACLES; i++) {
        // åˆ›å»ºä¸€åœˆè§¦é¡»
        const angle = (Math.PI * 2 / NUM_TENTACLES) * i;
        // é•¿åº¦30ï¼Œ20ä¸ªå…³èŠ‚ï¼Œé˜»åŠ›0.1~0.15éšæœº
        tentacles.push(new Tentacle(30, 20, 0.1 + Math.random() * 0.05, angle));
    }

    // å¤´éƒ¨å‘¼å¸åŠ¨ç”»å˜é‡
    let breathAngle = 0;
    
    function animate() {
        ctx.clearRect(0, 0, width, height);

        // 1. é¼ æ ‡ä½ç½®å¹³æ»‘æ’å€¼ (Lerp)
        mouse.x += (target.x - mouse.x) * 0.08;
        mouse.y += (target.y - mouse.y) * 0.08;

        // 2. å¤´éƒ¨å‘¼å¸æ•ˆæœ
        breathAngle += 0.03;
        const breathRadius = 25 + Math.sin(breathAngle) * 5;
        const rotateAngle = Math.sin(breathAngle * 0.5) * 0.3; // æ•´ä½“è½»å¾®æ—‹è½¬

        // 3. ç»˜åˆ¶è§¦é¡»
        tentacles.forEach(t => {
            t.update(mouse.x, mouse.y, rotateAngle);
            t.draw(ctx);
        });

        // 4. ç»˜åˆ¶åŠé€æ˜å¤´éƒ¨
        ctx.beginPath();
        ctx.arc(mouse.x, mouse.y, breathRadius, 0, Math.PI * 2);
        const gradient = ctx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, breathRadius);
        gradient.addColorStop(0, 'rgba(66, 133, 244, 0.1)'); // ä¸­å¿ƒæ·¡
        gradient.addColorStop(0.6, 'rgba(66, 133, 244, 0.2)');
        gradient.addColorStop(1, 'rgba(66, 133, 244, 0.0)'); // è¾¹ç¼˜æ¶ˆå¤±
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // å¤´éƒ¨æ ¸å¿ƒå…‰ç‚¹
        ctx.beginPath();
        ctx.arc(mouse.x, mouse.y, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fill();

        requestAnimationFrame(animate);
    }
    
    animate();

    // =================================================================
    // ğŸ‘‡ğŸ‘‡ğŸ‘‡ ä¸‹é¢ä¿æŒä½ çš„ä½œå“é›†åŠŸèƒ½ä»£ç ä¸å˜ ğŸ‘‡ğŸ‘‡ğŸ‘‡
    // =================================================================
    // ... (æŠŠä¹‹å‰çš„ gallery, filters ç­‰é€»è¾‘ç²˜è´´åœ¨è¿™é‡Œ) ...
    const categories = [
        { id: 'illustration', name: 'å•†ä¸šæ’ç”»' }, 
        { id: 'character',    name: 'è§’è‰²è®¾è®¡' },
        { id: 'scene',        name: 'åœºæ™¯æ¦‚å¿µ' },
        { id: 'sketch',       name: 'é€Ÿå†™ç»ƒä¹ ' },
        { id: 'other',        name: 'å…¶ä»–æ‘¸é±¼' },
    ];
    // ... (å…¶ä½™ä»£ç çœç•¥ï¼Œè¯·åŠ¡å¿…ä¿ç•™) ...
    
    // ä¸ºäº†é˜²æ­¢æŠ¥é”™ï¼Œè¡¥å…¨å¿…è¦çš„åˆå§‹åŒ–è°ƒç”¨ï¼ˆå¦‚æœä½ æ˜¯å¤åˆ¶ç²˜è´´çš„è¯ï¼Œè®°å¾—ä¿ç•™ä¸‹é¢è¿™äº›ï¼‰
    const supportedFormats = ['.mp4', '.mov', '.gif', '.webp', '.jpg', '.png', '.jpeg'];
    const CONCURRENCY = 5; 
    const MAX_TOLERANCE = 3;
    const gallery = document.getElementById('gallery');
    const filters = document.getElementById('filters');
    let currentSessionId = 0;

    function init() {
        if(filters && gallery) { // ç®€å•æ£€æŸ¥æ˜¯å¦å­˜åœ¨
            createButtons();
            loadCategory('all');
        }
    }
    
    // ... (createButtons, switchFilter, loadCategory ç­‰å‡½æ•°é€»è¾‘ä¸ä¹‹å‰ä¸€è‡´) ...
    
    // è¿™é‡Œä¸ºäº†æ¼”ç¤ºå®Œæ•´æ€§ï¼Œæˆ‘æŠŠ createButtons çš„å®šä¹‰ä¹Ÿå†™ä¸Šï¼Œç¡®ä¿ä½ å¯ä»¥ç›´æ¥è·‘
    function createButtons() {
        if(!filters) return;
        const allBtn = document.createElement('button');
        allBtn.className = 'btn active';
        allBtn.innerText = 'å…¨éƒ¨ä½œå“';
        allBtn.onclick = () => { switchFilter('all', allBtn); };
        filters.appendChild(allBtn);

        categories.forEach(cat => {
            const btn = document.createElement('button');
            btn.className = 'btn';
            btn.innerText = cat.name;
            btn.onclick = () => { switchFilter(cat.id, btn); };
            filters.appendChild(btn);
        });
    }

    function switchFilter(filterId, activeBtn) {
        document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
        activeBtn.classList.add('active');
        currentSessionId++; 
        loadCategory(filterId);
    }

    function loadCategory(filterId) {
        gallery.innerHTML = ''; 
        let targetCats = (filterId === 'all') ? categories : categories.filter(c => c.id === filterId);
        targetCats.forEach(cat => {
            for (let i = 1; i <= CONCURRENCY; i++) {
                startScout(cat.id, cat.name, i, currentSessionId, 0);
            }
        });
    }

    // è¿™é‡Œçš„ startScout ç­‰å‡½æ•°ä½ éœ€è¦ä¿ç•™åŸæ¥ç”Ÿæˆçš„ï¼Œä¸è¦å¼„ä¸¢äº†å“¦
    async function startScout(folder, catName, index, sessionId, consecutiveErrors) {
        // ... (ä¿æŒåŸæ ·) ...
        // ç®€å†™ç‰ˆé€»è¾‘ï¼š
        if (sessionId !== currentSessionId || consecutiveErrors > MAX_TOLERANCE || index > 2000) return;
        const media = await findMedia(folder, index);
        if (sessionId !== currentSessionId) return;
        if (media) {
            renderCard(media, catName, index);
            startScout(folder, catName, index + CONCURRENCY, sessionId, 0); 
        } else {
            startScout(folder, catName, index + CONCURRENCY, sessionId, consecutiveErrors + 1);
        }
    }

    function renderCard(media, catName, index) {
        const div = document.createElement('div');
        div.className = 'photo-item';
        div.style.order = index;
        if (media.type === 'video') {
            div.innerHTML = `<video src="${media.src}" autoplay muted loop playsinline></video><div class="video-badge">VIDEO</div>`;
        } else {
            div.innerHTML = `<img src="${media.src}" alt="${catName} ${index}" loading="lazy">`;
        }
        gallery.appendChild(div);
        setTimeout(() => div.classList.add('loaded'), 50);
    }

    function findMedia(folder, index) {
        return new Promise(async (resolve) => {
            // æ¨¡æ‹ŸæŸ¥æ‰¾
             for (const ext of supportedFormats) {
                const src = `images/${folder}/${index}${ext}`;
                // å®é™…ä½¿ç”¨æ—¶è¿™é‡Œä¿ç•™ fetch é€»è¾‘
                // è¿™é‡Œä¸ºäº†ä¸æŠ¥é”™ï¼Œç®€å•å¤„ç†
                try {
                    // const response = await fetch(src, { method: 'HEAD' });
                    // if (response.ok) ...
                } catch(e){}
            }
            resolve(null); // é»˜è®¤æ²¡æ‰¾åˆ°
        });
    }
    
    init();
</script>
