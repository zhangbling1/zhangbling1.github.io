<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Antigravity | Portfolio</title>
    <style>
        /* éšè—æ»šåŠ¨æ¡ï¼Œæ²‰æµ¸å¼ä½“éªŒ */
        body { margin: 0; overflow: hidden; background-color: #f8f9fa; font-family: 'Google Sans', sans-serif; }
        canvas { display: block; }
        
        /* ä½ çš„ä½œå“é›† UI å±‚ (ä¿æŒä¸å˜) */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        header { background: rgba(255,255,255,0.8); backdrop-filter: blur(10px); padding: 40px 60px; border-radius: 24px; box-shadow: 0 4px 30px rgba(0,0,0,0.05); text-align: center; pointer-events: auto; transition: transform 0.3s ease; }
        header:hover { transform: translateY(-5px); }
        h1 { margin: 0; color: #202124; font-size: 2.5rem; letter-spacing: -0.5px; }
        p { margin-top: 10px; color: #5f6368; }
        .btn { margin-top: 20px; padding: 10px 24px; background: #1a73e8; color: white; border: none; border-radius: 50px; font-size: 1rem; cursor: pointer; transition: background 0.2s; }
        .btn:hover { background: #1557b0; }
    </style>
</head>
<body>

    <div class="ui-layer">
        <header>
            <h1>My Portfolio</h1>
            <p>Visual Design & Artworks</p>
            <button class="btn">Enter Gallery</button>
        </header>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        /**
         * ğŸŒŠ 1:1 å¤åˆ»ç‰ˆï¼šåŸºäº Poisson Disk Sampling (æ³Šæ¾ç›˜é‡‡æ ·)
         * å‚è€ƒè‡ªä¸Šä¼ æ–‡ä»¶ main-F3FYKJAU.js ä¸­çš„é€»è¾‘
         */
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let particles = [];
        
        // ğŸ­ é¼ æ ‡ç‰©ç†å‚æ•°
        const mouse = { x: -1000, y: -1000 };
        const target = { x: -1000, y: -1000 };

        // âš™ï¸ é…ç½®ï¼šè°ƒæ•´è¿™é‡Œå¯ä»¥æ”¹å˜æ‰‹æ„Ÿ
        const CONFIG = {
            pointDistance: 25,  // ç‚¹ä¸ç‚¹ä¹‹é—´çš„é—´è· (æ§åˆ¶å¯†åº¦)
            mouseForce: 1500,   // é¼ æ ‡å¸å¼•åŠ›å¼ºåº¦ (è¶Šå¤§å¸å¾—è¶Šç´§)
            friction: 0.94,     // æ‘©æ“¦åŠ› (0.9 ~ 0.99, è¶Šå¤§è¶Šæ»‘)
            returnForce: 0.04,  // å›å¼¹åŠ› (æ§åˆ¶ç‚¹å›åˆ°åŸä½çš„é€Ÿåº¦)
            color: '#4285F4'    // Google Blue
        };

        // -----------------------------------------------------------
        // ğŸ“ æç®€ç‰ˆæ³Šæ¾ç›˜é‡‡æ · (æ¨¡æ‹Ÿæ–‡ä»¶ä¸­çš„åˆ†å¸ƒç®—æ³•)
        // ç›®çš„ï¼šè®©ç‚¹åˆ†å¸ƒå¾—æå…¶å‡åŒ€ï¼Œä½†åˆä¸æ˜¯æ­»æ¿çš„ç½‘æ ¼
        // -----------------------------------------------------------
        function generatePoissonPoints(w, h, minDist) {
            const k = 30; // æœ€å¤§å°è¯•æ¬¡æ•°
            const cellSize = minDist / Math.sqrt(2);
            const gridW = Math.ceil(w / cellSize);
            const gridH = Math.ceil(h / cellSize);
            const grid = new Array(gridW * gridH).fill(-1);
            const activeList = [];
            const points = [];

            // éšæœºæ·»åŠ ç¬¬ä¸€ä¸ªç‚¹
            const firstPoint = { x: Math.random() * w, y: Math.random() * h };
            activeList.push(firstPoint);
            points.push(firstPoint);
            
            const col = Math.floor(firstPoint.x / cellSize);
            const row = Math.floor(firstPoint.y / cellSize);
            grid[col + row * gridW] = 0; // ç´¢å¼• 0

            while (activeList.length > 0) {
                const randIndex = Math.floor(Math.random() * activeList.length);
                const pos = activeList[randIndex];
                let found = false;

                for (let i = 0; i < k; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * minDist + minDist; // minDist ~ 2*minDist
                    const newX = pos.x + Math.cos(angle) * dist;
                    const newY = pos.y + Math.sin(angle) * dist;

                    if (newX >= 0 && newX < w && newY >= 0 && newY < h) {
                        const newCol = Math.floor(newX / cellSize);
                        const newRow = Math.floor(newY / cellSize);
                        let ok = true;

                        // æ£€æŸ¥é‚»å±…
                        for (let x = -1; x <= 1; x++) {
                            for (let y = -1; y <= 1; y++) {
                                const neighborIndex = (newCol + x) + (newRow + y) * gridW;
                                const neighborPointIndex = grid[neighborIndex];
                                if (neighborPointIndex !== undefined && neighborPointIndex !== -1) {
                                    const neighbor = points[neighborPointIndex];
                                    const d = Math.hypot(neighbor.x - newX, neighbor.y - newY);
                                    if (d < minDist) {
                                        ok = false;
                                    }
                                }
                            }
                        }

                        if (ok) {
                            const newPoint = { x: newX, y: newY };
                            activeList.push(newPoint);
                            points.push(newPoint);
                            grid[newCol + newRow * gridW] = points.length - 1;
                            found = true;
                            break; // æ‰¾åˆ°äº†ä¸€ä¸ªæœ‰æ•ˆç‚¹ï¼Œåœæ­¢å°è¯•
                        }
                    }
                }

                if (!found) {
                    activeList.splice(randIndex, 1);
                }
            }
            return points;
        }

        // -----------------------------------------------------------
        // ğŸ§ª ç²’å­ç±»
        // -----------------------------------------------------------
        class Particle {
            constructor(x, y) {
                this.originX = x; // åŸå§‹ä½ç½® (Home)
                this.originY = y;
                this.x = x;       // å½“å‰ä½ç½®
                this.y = y;
                this.vx = 0;      // é€Ÿåº¦
                this.vy = 0;
                this.size = Math.random() * 1.5 + 1; // éšæœºå¤§å° 1~2.5
            }

            update() {
                // 1. è®¡ç®—é¼ æ ‡è·ç¦»
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const distSq = dx * dx + dy * dy;

                // 2. é¼ æ ‡å¸å¼•åŠ› (è·ç¦»è¶Šè¿‘ï¼Œå¸åŠ›è¶Šå¤§ï¼Œä½†æœ‰ä¸Šé™)
                // è¿™ç§éçº¿æ€§åŠ›åœºèƒ½åˆ¶é€ å‡º"æ°´æ¯è§¦é¡»"èˆ¬çš„æ‹–å°¾æ„Ÿ
                let force = 0;
                if (distSq < 100000) { // åªæœ‰é è¿‘é¼ æ ‡æ‰æœ‰ååº”
                    force = CONFIG.mouseForce / (distSq + 500); 
                }

                const angle = Math.atan2(dy, dx);
                const ax = Math.cos(angle) * force;
                const ay = Math.sin(angle) * force;

                // 3. å›å¼¹åŠ› (Spring Force) - è®©ç‚¹æƒ³å›åˆ°åŸä½
                const homeDx = this.originX - this.x;
                const homeDy = this.originY - this.y;
                
                this.vx += ax + homeDx * CONFIG.returnForce;
                this.vy += ay + homeDy * CONFIG.returnForce;

                // 4. ç‰©ç†æ‘©æ“¦
                this.vx *= CONFIG.friction;
                this.vy *= CONFIG.friction;

                // 5. æ›´æ–°ä½ç½®
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = CONFIG.color;
                ctx.fill();
            }
        }

        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            
            // ä½¿ç”¨æ³Šæ¾åˆ†å¸ƒç”Ÿæˆç‚¹
            const points = generatePoissonPoints(width, height, CONFIG.pointDistance);
            
            particles = [];
            points.forEach(p => {
                particles.push(new Particle(p.x, p.y));
            });
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);
            
            // é¼ æ ‡å¹³æ»‘æ’å€¼
            mouse.x += (target.x - mouse.x) * 0.15;
            mouse.y += (target.y - mouse.y) * 0.15;

            particles.forEach(p => {
                p.update();
                p.draw();
            });

            requestAnimationFrame(animate);
        }

        // äº‹ä»¶ç›‘å¬
        window.addEventListener('resize', init);
        window.addEventListener('mousemove', e => {
            target.x = e.clientX;
            target.y = e.clientY;
            // åˆå§‹æ¿€æ´»
            if (mouse.x === -1000) { mouse.x = e.clientX; mouse.y = e.clientY; }
        });

        init();
        animate();
    </script>
</body>
</html>
