<!DOCTYPE html> 
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Antigravity | Radial Flow</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f8f9fa; font-family: 'Google Sans', sans-serif; }
        canvas { display: block; position: fixed; top: 0; left: 0; z-index: 0; }
        
        /* UI 层 */
        .ui-layer { position: relative; z-index: 10; width: 100%; height: 100vh; pointer-events: none; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        header { pointer-events: auto; background: rgba(255,255,255,0.95); backdrop-filter: blur(20px); padding: 50px 70px; border-radius: 24px; box-shadow: 0 10px 40px rgba(0,0,0,0.06); text-align: center; border: 1px solid rgba(255,255,255,0.5); }
        h1 { margin: 0; color: #1f1f1f; font-size: 3.5rem; letter-spacing: -1.5px; font-weight: 600; }
        p.subtitle { margin-top: 10px; color: #5f6368; font-size: 1.1rem; }
        
        .gallery-container { display: none; }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>

    <div class="ui-layer">
        <header>
            <h1>Antigravity</h1>
            <p class="subtitle">Pure Radial Diffusion — Jelly / silky motion (clean look)</p>
        </header>
    </div>

    <div class="gallery-container" id="gallery"></div>

    <script>
        /**
         * 调整版：去“近视模糊”、点更小更清晰、密度降低
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // ⚙️ 参数（已按你反馈调整）
        const CONFIG = {
            pointDist: 40,        // 点间距（增大 = 更稀）
            maxParticles: 900,    // 上限，防止过密

            cursorRadius: 180,
            pushStrength: 48,     // 推力减小（不拉太远）
            pushFalloff: 0.9,

            friction: 0.86,
            returnSpeed: 0.06,
            inertiaLerp: 0.12,

            color: [66,133,244],
            baseSize: 0.9,        // 核更小
            glowSize: 5,          // 光晕缩小（防止整帧糊）

            globalFreq: 0.18,
            localFreqRange: [0.9, 1.5],
            noiseAmount: 0.45
        };

        let DPR = Math.max(1, window.devicePixelRatio || 1);
        let width, height;
        let particles = [];
        const mouse = { x: -9999, y: -9999, active: false };

        // Poisson Disk (保留)
        function generatePoissonPoints(w, h, r) {
            const k = 30;
            const cellSize = r / Math.sqrt(2);
            const gridW = Math.ceil(w / cellSize);
            const gridH = Math.ceil(h / cellSize);
            const grid = new Array(gridW * gridH).fill(-1);
            const active = [];
            const p = [];

            const x0 = Math.random() * w;
            const y0 = Math.random() * h;
            const i0 = Math.floor(x0 / cellSize);
            const j0 = Math.floor(y0 / cellSize);
            const pos0 = { x: x0, y: y0 };
            
            p.push(pos0);
            active.push(pos0);
            grid[i0 + j0 * gridW] = 0;

            while (active.length > 0) {
                const randIndex = Math.floor(Math.random() * active.length);
                const center = active[randIndex];
                let found = false;

                for (let i = 0; i < k; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = r + Math.random() * r;
                    const newX = center.x + Math.cos(angle) * dist;
                    const newY = center.y + Math.sin(angle) * dist;

                    if (newX >= 0 && newX < w && newY >= 0 && newY < h) {
                        const col = Math.floor(newX / cellSize);
                        const row = Math.floor(newY / cellSize);
                        let ok = true;

                        for (let xOff = -1; xOff <= 1; xOff++) {
                            for (let yOff = -1; yOff <= 1; yOff++) {
                                const idx = (col + xOff) + (row + yOff) * gridW;
                                if (idx >= 0 && idx < grid.length && grid[idx] !== -1) {
                                    const neighbor = p[grid[idx]];
                                    const d = (newX - neighbor.x) ** 2 + (newY - neighbor.y) ** 2;
                                    if (d < r * r) ok = false;
                                }
                            }
                        }

                        if (ok) {
                            const newPoint = { x: newX, y: newY };
                            active.push(newPoint);
                            p.push(newPoint);
                            grid[col + row * gridW] = p.length - 1;
                            found = true;
                            break;
                        }
                    }
                }
                if (!found) active.splice(randIndex, 1);
                if (p.length >= CONFIG.maxParticles) break;
            }
            return p;
        }

        // tiny deterministic noise
        function hashTo(seed) { return fract(Math.sin(seed * 127.1) * 43758.5453); }
        function fract(x) { return x - Math.floor(x); }
        function pseudoNoise(x, y) { const s = x * 12.9898 + y * 78.233; return hashTo(s); }

        class Particle {
            constructor(x, y) {
                this.originX = x;
                this.originY = y;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.phase = Math.random() * Math.PI * 2;
                this.localFreq = lerp(CONFIG.localFreqRange[0], CONFIG.localFreqRange[1], Math.random());
                this.seed = (x * 73856093) ^ (y * 19349663) ^ Math.floor(Math.random()*1000);
                this.targetOffsetX = 0;
                this.targetOffsetY = 0;
            }

            computeLocalBreath(t) {
                return Math.sin( (t * CONFIG.globalFreq * this.localFreq) + this.phase );
            }

            update(t, dt) {
                const breath = this.computeLocalBreath(t) * 0.55;
                const n = (pseudoNoise(this.originX * 0.01 + t * 0.09, this.originY * 0.01) - 0.5) * CONFIG.noiseAmount;

                const dx = this.x - mouse.x;
                const dy = this.y - mouse.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                let pushX = 0, pushY = 0;

                if (mouse.active && dist < CONFIG.cursorRadius) {
                    const nx = dx / (dist || 1);
                    const ny = dy / (dist || 1);
                    const force = Math.pow((CONFIG.cursorRadius - dist) / CONFIG.cursorRadius, 1.15);
                    const push = CONFIG.pushStrength * force * 0.01;
                    const curl = Math.sin(this.phase + t * 0.8) * 0.25;
                    const rx = nx * Math.cos(curl) - ny * Math.sin(curl);
                    const ry = nx * Math.sin(curl) + ny * Math.cos(curl);

                    pushX = rx * push * (1 + breath * 0.35);
                    pushY = ry * push * (1 + breath * 0.35);
                }

                const passiveX = (Math.cos(this.phase + t * 0.4) * 0.5 + n * 0.85) * breath * 0.45;
                const passiveY = (Math.sin(this.phase + t * 0.36) * 0.5 + n * 0.9) * breath * 0.45;

                const targetOffX = pushX + passiveX;
                const targetOffY = pushY + passiveY;

                this.targetOffsetX = lerp(this.targetOffsetX, targetOffX, 0.14);
                this.targetOffsetY = lerp(this.targetOffsetY, targetOffY, 0.14);

                const desiredX = this.originX + this.targetOffsetX * CONFIG.pointDist * 0.7;
                const desiredY = this.originY + this.targetOffsetY * CONFIG.pointDist * 0.7;

                const ax = (desiredX - this.x) * CONFIG.returnSpeed;
                const ay = (desiredY - this.y) * CONFIG.returnSpeed;

                this.vx = lerp(this.vx, this.vx + ax, CONFIG.inertiaLerp);
                this.vy = lerp(this.vy, this.vy + ay, CONFIG.inertiaLerp);

                this.vx *= CONFIG.friction;
                this.vy *= CONFIG.friction;

                this.x += this.vx;
                this.y += this.vy;

                this.phase += 0.002 + 0.0004 * (this.localFreq - 1) + dt * 0.18;
            }

            draw(ctx, t) {
                const dx0 = this.x - this.originX;
                const dy0 = this.y - this.originY;
                const displacement = Math.sqrt(dx0*dx0 + dy0*dy0);

                const size = CONFIG.baseSize + Math.min(displacement * 0.06, 3.2);
                const alphaCore = clamp(0.18 + Math.min(displacement * 0.04, 0.45), 0.07, 0.9);
                const col = CONFIG.color;

                // draw crisp inner core (small)
                ctx.beginPath();
                ctx.fillStyle = `rgba(${col[0]},${col[1]},${col[2]},${alphaCore})`;
                ctx.arc(this.x, this.y, Math.max(0.8, size * 0.9), 0, Math.PI * 2);
                ctx.fill();

                // soft outer glow (very subtle, prevents模糊感)
                const r = size * CONFIG.glowSize;
                const gx = this.x;
                const gy = this.y;
                const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, r);
                g.addColorStop(0, `rgba(${col[0]},${col[1]},${col[2]},${alphaCore * 0.36})`);
                g.addColorStop(0.35, `rgba(${col[0]},${col[1]},${col[2]},${Math.max(0.02, alphaCore * 0.12)})`);
                g.addColorStop(1, `rgba(${col[0]},${col[1]},${col[2]},${0.005})`);

                // draw gradient with additive but very low intensity
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(gx, gy, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // helpers
        function lerp(a, b, t) { return a + (b - a) * t; }
        function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

        // resize / regenerate
        let lastTime = performance.now();
        function resize() {
            DPR = Math.max(1, window.devicePixelRatio || 1);
            width = canvas.width = Math.floor(window.innerWidth * DPR);
            height = canvas.height = Math.floor(window.innerHeight * DPR);
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            regenerateParticles();
        }

        function regenerateParticles() {
            const w = Math.floor(window.innerWidth);
            const h = Math.floor(window.innerHeight);
            const points = generatePoissonPoints(w, h, CONFIG.pointDist);
            particles = points.slice(0, CONFIG.maxParticles).map(p => new Particle(p.x, p.y));
        }

        function animate(now) {
            const dtMs = now - lastTime;
            const dt = Math.min(dtMs / 1000, 0.033);
            lastTime = now;
            const t = now * 0.001;

            ctx.clearRect(0, 0, width, height);

            // draw particles in CSS-pixel space
            ctx.save();
            ctx.scale(DPR, DPR);

            for (let i = 0; i < particles.length; i++) {
                particles[i].update(t, dt);
                particles[i].draw(ctx, t);
            }

            ctx.restore();

            requestAnimationFrame(animate);
        }

        // interaction
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            mouse.active = true;
        });

        window.addEventListener('mouseleave', () => {
            mouse.x = -9999;
            mouse.y = -9999;
            mouse.active = false;
        });

        window.addEventListener('touchmove', (ev) => {
            const t = ev.touches[0];
            if (t) {
                mouse.x = t.clientX;
                mouse.y = t.clientY;
                mouse.active = true;
            }
        }, { passive: true });

        window.addEventListener('touchend', () => {
            mouse.active = false;
            mouse.x = -9999;
            mouse.y = -9999;
        });

        window.addEventListener('resize', () => { resize(); });

        // init
        resize();
        lastTime = performance.now();
        requestAnimationFrame(animate);

        // keep categories placeholder
        const categories = [
            { id: 'illustration', name: 'Commercial Illustration' }, 
            { id: 'character',    name: 'Character Design' },
            { id: 'scene',        name: 'Environment Art' },
            { id: 'sketch',       name: 'Sketches & Doodles' },
            { id: 'other',        name: 'Others' },
        ];
    </script>
</body>
</html>
